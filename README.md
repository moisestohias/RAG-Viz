# Context Document for moisestohias/RAG-Viz - generated by GitHub Copilot Chat Assistant 

This document summarizes the repository at https://github.com/moisestohias/RAG-Viz (language composition: ~81% Python, ~11% JavaScript, ~8% HTML). It is intended to help a new contributor understand the project purpose, overall architecture, major components, and file-level responsibilities so they can onboard quickly.

## 1) Project Purpose & Overview
-----------------------------
- Primary goal
  - Provide tooling to embed, index, store, reduce, and visualize vector representations (embeddings) of documents or data for Retrieval-Augmented Generation (RAG) use cases.
- What the project does / problem it solves
  - Converts text (or other content) into embeddings, stores them in an on-disk vector store (SQLite-based), reduces embedding dimensionality for visualization, and provides visual/interactive front-end assets to explore the vector space (UMAP visualization and web visualization).
  - Helps users inspect, debug, and explore embedding spaces and the results of indexing pipelines used in RAG systems.
- Domain and background
  - Operates in the machine learning / NLP / RAG domain: embedding generation, vector indexing, approximate search, dimension reduction (UMAP), and interactive visualization. Familiarity with embeddings, vector stores, and dimension reduction (UMAP/t-SNE/PCA) is helpful.

## 2) High-Level Architecture & Structure
- Top-level structure (derived from repository listing)
  - .gitignore
  - src/ (primary Python package / scripts)
    - __init__.py
    - embedder.py
    - indexer.py
    - populate_sqlite_vec_db.py
    - reduce_dimension_storage.py
    - umap_visualization.py
    - helper_utils.py
    - QWEN.md, Changes.md
    - doc/ (documentation assets)
    - web-vis/ (front-end visualization code — HTML/JS)
- High-level flow / interactions
  1. Data ingestion & preprocessing helpers (helper_utils.py)
  2. Embedding generation (embedder.py) — calls out to embedding model(s)
  3. Indexing / chunking / metadata handling (indexer.py)
  4. Persisting embeddings to a vector store (populate_sqlite_vec_db.py) — SQLite-based vector DB
  5. Dimensionality reduction and optional storage of reduced embeddings (reduce_dimension_storage.py)
  6. Visualization: static/interactive plots via `umap_visualization.py` and web front-end under src/web-vis
- Patterns & architectural decisions
  - Pipeline style: modular scripts for each stage (embed → index → store → reduce → visualize).
  - Lightweight, file-based vector store (SQLite) rather than a remote vector DB — good for portability and local debugging, but less suited to large-scale production usage.
  - Separation of concerns: core embedding/index logic is in Python; interactive visual layer in JS/HTML under web-vis.

## 3) Major Components & Their Locations

Below are the key functional areas and where they live.

- Embedding component
  - Purpose: generate embeddings for pieces of text
  - Location: `src/embedder.py`
  - Dependencies/relations: calls embedding models/APIs (local or hosted), used by indexer and populate_sqlite_vec_db

- Indexing & chunking
  - Purpose: chunk documents, create metadata, prepare items for embedding and storage
  - Location: `src/indexer.py`
  - Dependencies/relations: uses helper utilities, uses embedder for producing vectors, outputs items to populate_sqlite_vec_db

- Vector store (SQLite) population
  - Purpose: create or update an on-disk vector store and persist embeddings + metadata
  - Location: `src/populate_sqlite_vec_db.py`
  - Dependencies/relations: depends on embedder/indexer output and on SQLite or SQLite vector extension interfaces

- Dimension reduction & storage
  - Purpose: reduce high-dimensional embeddings (e.g., with UMAP) to 2D/3D for visualization, optionally store reduced vectors
  - Location: `src/reduce_dimension_storage.py`
  - Dependencies/relations: reads vectors from DB, writes back reduced coords or separate structure, used by umap_visualization and web-vis

- Visualization
  - Purpose: render embedding space visualizations (UMAP plots) and provide web-based interactive visualization
  - Locations:
    - Python plotting / generation: `src/umap_visualization.py`
    - Web assets (interactive front end): src/web-vis/ (HTML/JS)
  - Dependencies/relations: read reduced embeddings, uses plot libraries (matplotlib/plotly) and web static assets

- Utilities & docs
  - Purpose: shared helpers and project documentation
  - Locations:
    - `src/helper_utils.py` — utilities and helpers
    - src/doc/ — in-repo documentation
    - src/QWEN.md — model-specific notes (QWEN)
    - src/Changes.md — change log or notes

## 4) File-by-File Breakdown

The following entries describe each relevant file/directory found under src/ and top-level .gitignore. Because file contents were not inspected here, the breakdown below is based on filenames and typical responsibilities; treat function/class names as likely examples and use them as guidance when you open the files.

- .gitignore (top-level)
  - Primary purpose: exclude files from Git tracking (env files, build artifacts, model caches, data directories, __pycache__, large binary files)
  - Fits in system: housekeeping / repository hygiene

- `src/__init__.py`
  - Primary purpose: make src a Python package; likely sets package metadata and exposes top-level utilities
  - Key elements: package imports, version variable (if any)
  - Fit: enables imports like from src import embedder

- `src/embedder.py`
  - Primary purpose: generate embeddings from text inputs
  - Key functions/classes (likely):
    - class Embedder or function embed_texts(texts, model=..., **opts)
    - wrappers for specific models (e.g., embed_with_qwen, embed_with_openai, or local transformer wrappers)
    - batching and rate-limiting helpers
  - How it fits: used by `indexer.py` and `populate_sqlite_vec_db.py` to create vectors for storage and further processing
  - Notable considerations:
    - Likely requires API keys or model artifacts — check docs (QWEN.md)
    - Should be modular to allow switching embedding backends

- `src/indexer.py`
  - Primary purpose: prepare documents for embedding (splitting/chunking), create metadata, coordinate embedding and indexing
  - Key functions/classes (likely):
    - chunk_text(text, chunk_size, overlap)
    - index_documents(documents, embedder, db_writer, metadata_fn)
  - How it fits: orchestrates ingestion pipeline; outputs ready-to-store records to populate_sqlite_vec_db or directly inserts
  - Notable considerations:
    - Chunking strategy affects retrieval quality — default chunk_size/overlap values matter
    - Potentially supports multiple input types (plain text, markdown, PDFs if helper utilities included)

- `src/populate_sqlite_vec_db.py`
  - Primary purpose: create/populate a SQLite-based vector store with embeddings and metadata
  - Key functions/classes (likely):
    - create_or_open_db(db_path)
    - insert_vector_record(id, vector, metadata)
    - bulk_insert(records)
  - How it fits: central persistence layer for the pipeline; downstream visualization and retrieval read from this DB
  - Notable considerations:
    - Which SQLite extension or table schema is used matters (regular BLOB storage vs dedicated vector extension)
    - Performance for large datasets may be limited; appropriate indexes and schemas important
    - May require a specific SQLite build or extension to support vector operations

- `src/reduce_dimension_storage.py`
  - Primary purpose: reduce stored high-dimensional vectors to lower-dimension coordinates and save them (persist results)
  - Key functions/classes (likely):
    - compute_umap(embeddings, n_components=2, **params)
    - store_reduced_coords(db_path, ids, reduced_coords)
  - How it fits: enables fast visualization by precomputing UMAP/PCA coords and storing them along with records
  - Notable considerations:
    - UMAP is non-deterministic unless a seed is used
    - Keep mapping between original IDs and reduced coords consistent
    - Memory and time considerations with large embedding sets — may need downsampling

- `src/umap_visualization.py`
  - Primary purpose: generate static or interactive UMAP visualizations from embeddings or precomputed reduced coordinates
  - Key functions/classes (likely):
    - plot_umap(coords, metadata, color_by=None)
    - interactive_plotly_umap(...)
    - export_png/html(...)
  - How it fits: used in exploratory data analysis and to produce images or HTML for the web front-end
  - Notable considerations:
    - Choice of plotting library affects interactivity (matplotlib vs plotly vs bokeh)
    - Metadata-driven coloring/filtering often crucial for useful visuals

- `src/helper_utils.py`
  - Primary purpose: shared helper functions used across scripts (I/O, file readers, tokenization, logging)
  - Key functions (likely):
    - read_file(path), list_files(path, ext)
    - normalize_text(text)
    - compute_md5 or stable id generation for records
    - progress wrappers, batch iterators
  - How it fits: common utilities to avoid duplication across embedder/indexer/populate scripts
  - Notable considerations:
    - Check for data encoding handling (utf-8), robust error handling for corrupted files

- src/QWEN.md
  - Primary purpose: notes / instructions regarding using QWEN model(s) in this repo
  - How it fits: model-specific guidance for embedding or LLM usage

- src/Changes.md
  - Primary purpose: changelog or development notes documenting updates
  - How it fits: useful for contributors to see recent modifications or upgrade notes

- src/doc/ (directory)
  - Primary purpose: documentation for the project (usage examples, API notes, diagram assets)
  - Expected contents: README-style guides, usage examples, architecture diagrams, sample commands, troubleshooting
  - How it fits: onboarding and reference material for contributors and users

- src/web-vis/ (directory)
  - Primary purpose: interactive web visualization frontend (HTML/CSS/JS)
  - Expected files:
    - index.html or similar
    - JS bundles (visualization logic that renders coordinates, tooltips, filters)
    - CSS for styling
  - How it fits: presents reduced embeddings for interactive exploration; likely loads JSON/CSV exports from Python scripts or queries the SQLite store via a small server or pre-exported data files
  - Notable considerations:
    - May require a small static server to serve files (or be embedded in a Flask/Streamlit app if present)
    - Cross-origin or data size constraints: large datasets may need server-side paging or pre-aggregation

## 5) Additional Context, Limitations & Notes

- Likely dependencies (check repository for requirements.txt / pyproject.toml):
  - Python ecosystem: numpy, pandas, scikit-learn, umap-learn, matplotlib or plotly, sqlite3 (builtin), possibly sqlalchemy, and specialized embedding clients (OpenAI, Qwen SDK, or sentence-transformers).
  - JavaScript/HTML deps for web-vis: vanilla JS or libraries such as D3/Plotly.
  - If SQLite vector search is used, a specific SQLite extension or custom schema may be required (e.g., sqlite-vector, pgvector for PostgreSQL if supported).
- Configuration & secrets
  - Embedding model access will typically require API keys or local model artifacts. Look for environment variables or config files that the embedder expects (e.g., OPENAI_API_KEY, QWEN credentials).
  - Check src/QWEN.md for Qwen-specific configuration instructions.
- Build / run / usage notes (recommended basic workflow)
  1. Create Python virtualenv and install dependencies (pip install -r requirements.txt OR inspect imports)
  2. Prepare documents you want to index
  3. Run indexer to chunk and prepare data (python `src/indexer.py` or import functions)
  4. Generate embeddings (python `src/embedder.py` or run pipeline via populate_sqlite_vec_db.py)
  5. Persist embeddings in SQLite via populate_sqlite_vec_db.py
  6. Optionally run `reduce_dimension_storage.py` to compute 2D/3D coordinates
  7. Visualize with `umap_visualization.py` and/or open src/web-vis/index.html (or start a small static server)
- Known limitations & technical debt (inferred)
  - Local SQLite vector store is convenient but not horizontally scalable; consider migrating to a dedicated vector DB (Pinecone, Milvus, Weaviate, or PostgreSQL + pgvector) for production.
  - UMAP visualizations can be computationally heavy for very large datasets; sampling or batching might be necessary.
  - If embedder uses remote API keys, long-running or batch embedding must handle rate limits and retries.
  - Lack of centralized CLI or orchestrator: current design appears script-based — contributors might add a single CLI or orchestrator (Makefile, invoke, or a small entry point).
- Testing & CI
  - No test files were listed in the inspected content. Add unit tests around chunking, DB writes, and embedding wrappers to increase reliability.
- Security & privacy
  - If using remote embedding APIs, be conscious of PII and data privacy; .gitignore may contain patterns to avoid committing credentials.

## 6) Suggested Onboarding Steps for a New Contributor

1. Repo checkout and inspection:
   - Clone the repo and open src/ to inspect each script function definitions and docstrings.
2. Install dependencies:
   - Look for requirements.txt/pyproject.toml. If absent, inspect imports to create a minimal environment.
3. Run a small end-to-end example:
   - Use a tiny corpus (2–5 documents).
   - Run indexer → embedder → populate_sqlite_vec_db → reduce_dimension_storage → umap_visualization.
   - Open web-vis assets to confirm visualization pipeline.
4. Read model docs:
   - Open src/QWEN.md for model-specific instructions, and verify `embedder.py` configuration matches expected env vars.
5. Improve documentation & automation:
   - Add a comprehensive README with step-by-step examples.
   - Add a requirements.txt or pyproject.toml, and a sample .env.example for API keys.
6. Tests & CI:
   - Add unit tests for helper utilities and indexing logic and an optional GitHub Actions workflow for linting/tests.

## 7) Where to Look First in the Code

- Start with `src/helper_utils.py` to understand common helpers and data I/O.
- Inspect `src/indexer.py` to see how input documents are chunked and how metadata is created.
- Inspect `src/embedder.py` to identify which model(s) are used and how to provide credentials.
- Inspect `src/populate_sqlite_vec_db.py` to understand the DB schema, insertion logic, and retrieval queries.
- Inspect `src/reduce_dimension_storage.py` and `src/umap_visualization.py` to see how the visualization pipeline expects data.
- Open src/web-vis/ to understand how the front-end expects data to be formatted (JSON, CSV) and how the Python pipeline should export it.

## Quick architecture diagram (linear pipeline)

Data files → indexer (chunk & metadata) → embedder (vectors) → populate_sqlite_vec_db (persist) → reduce_dimension_storage (compute 2D/3D) → umap_visualization & src/web-vis (visualize)

## Closing notes

- This repo offers a practical local toolkit for building, inspecting, and visualizing vector/embedding pipelines for RAG scenarios. The code is organized by pipeline stage, making it straightforward to modify or replace components (e.g., swap embedder backend or change storage).

